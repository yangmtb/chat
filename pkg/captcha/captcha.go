package captcha

import (
	"chat/pkg/random"
	"chat/pkg/store"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"
)

var (
	// GCLimitNumber The number of captchas created that triggers garbage collection used by default store.
	// 默认图像验证GC清理的上限个数
	GCLimitNumber = 10240
	// Expiration time of captchas used by default store.
	// 内存保存验证码的时限
	Expiration = 10 * time.Minute
	// globalStore is a shared storage for captchas, generated by New function.
	// 默认内存储存
	globalStore = store.NewMemoryStore(GCLimitNumber, Expiration)
)

// SetCustomStore set custom storage for captchas, replacing the default memory store.
// this function must be called before generating any captchas
func SetCustomStore(s store.Store) {
	globalStore = s
}

// Interface captcha interface for captcha engine to write staff
type Interface interface {
	// BinaryEncodeing covert to bytes
	BinaryEncodeing() []byte
	// WriteTo output captcha entity
	WriteTo(w io.Writer) (n int64, err error)
}

// WriteToBase64Encoding converts captcha to base64 encoding string.
// mimeType is one of "audio/waw" "image/png"
func WriteToBase64Encoding(cap CaptchaInterface) string {
	binaryData := cap.BinaryEncodeing()
	var mimeType string
	if _, ok := cap.(*Audio); ok {
		mimeType = MimeTypeCaptchaAudio
	} else {
		mimeType = MimeTypeCaptchaImage
	}
	return fmt.Sprintf("data:%s;base64,%s", mimeType, base64.StdEncoding.EncodeToString(binaryData))
}

// WriteToFile output captcha to file.
// fileExt is one of 'png', 'wav'
func WriteToFile(cap CaptchaInterface, outputDir, fileName, fileExt string) (err error) {
	filePath := filepath.Join(outputDir, fileName+"."+fileExt)
	fi, err := os.Create(filePath)
	if nil != err {
		return err
	}
	defer fi.Close()
	_, err = cap.WriteTo(fi)
	return
}

// Item captcha basic information
type Item struct {
	Content     string
	VerifyValue string
	ImageWidth  int
	ImageHeight int
}

// VerifyCaptcha by given id key and remove the captcha value in store,
// return boolean value.
func VerifyCaptcha(id, value string) bool {
	return VerifyCaptchaAndIsClear(id, value, true)
}

// VerifyCaptchaAndIsClear verify captcha, return boolean value.
func VerifyCaptchaAndIsClear(id, value string, clear bool) bool {
	if "" == value {
		return false
	}
	storeValue := globalStore.Get(id, false)
	if "" == storeValue {
		return false
	}
	result := strings.ToLower(storeValue) == strings.ToLower(value)
	if result {
		globalStore.Get(id, clear)
	}
	return result
}

// GenerateCaptcha ...
func GenerateCaptcha(key string, configuration interface{}) (id string, instance Interface) {
	if "" == key {
		key = random.RandomID()
	}
	id = key
	var verify string
	switch config := configuration.(type) {
	case ConfigAudio:
		audio := CreateAudioEngine(key, config)
		verify = audio.VerifyValue
		instance = audio
	case ConfigCharacter:
		char := CreateCharEngine(config)
		verify = char.VerifyValue
		instance = char
	case ConfigDigit:
		digit := CreateDigtsEngine(key, config)
		verify = digit.VerifyValue
		instance = digit
	default:
		log.Fatal("config type not supported", config)
	}
	globalStore.Set(key, verify)
	return
}
